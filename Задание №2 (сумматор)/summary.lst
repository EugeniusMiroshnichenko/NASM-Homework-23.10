     1                                  section .text
     2                                  
     3                                  global _start
     4                                  
     5                                  _start:
     6                                  
     7                                      ; Сообщение о первом числе
     8 00000000 B801000000                  mov rax, 0x1
     9 00000005 BF01000000                  mov rdi, 0x1
    10 0000000A 48BE-                       mov rsi, firstMes
    10 0000000C [0000000000000000] 
    11 00000014 BA14000000                  mov rdx, firstMesLen
    12 00000019 0F05                        syscall
    13                                      
    14 0000001B 4883F814                    cmp rax, firstMesLen ; rax не меняется, код ошибки не теряем, если она есть
    15 0000001F 0F8C56020000                JL errorSection ; % Выведено меньше символов, чем ожидалось (если есть ошибка, то результат автоматически будет отрицательным)
    16                                  
    17                                      ; Считываем первое число
    18 00000025 B800000000                  mov rax, 0
    19 0000002A BF00000000                  mov rdi, 0
    20 0000002F 48BE-                       mov rsi, firstNum
    20 00000031 [0000000000000000] 
    21 00000039 BA00010000                  mov rdx, 256
    22 0000003E 0F05                        syscall
    23                                      
    24 00000040 4883F800                    cmp rax, 0
    25 00000044 0F8E31020000                JLE errorSection; Ошибка - и 0, и отрицательное число
    26                                  
    27 0000004A 48890425[08000000]          mov [firstNumLen], rax
    28 00000052 48BF-                       mov rdi, firstNum
    28 00000054 [0000000000000000] 
    29 0000005C 488B1C25[08000000]          mov rbx, [firstNumLen]
    30                                  
    31 00000064 E80A010000                  call stringToNumberSection
    32                                      
    33 00000069 4989F2                      mov r10, rsi ; В r10 храним первое число
    34                                      
    35                                      ; Сообщение о втором числе
    36 0000006C B801000000                  mov rax, 0x1
    37 00000071 BF01000000                  mov rdi, 0x1
    38 00000076 48BE-                       mov rsi, secondMes
    38 00000078 [1400000000000000] 
    39 00000080 BA15000000                  mov rdx, secondMesLen
    40 00000085 0F05                        syscall
    41                                      
    42 00000087 4883F815                    cmp rax, secondMesLen ; rax не меняется, код ошибки не теряем, если она есть
    43 0000008B 0F8CEA010000                JL errorSection ; % Выведено меньше символов, чем ожидалось (если есть ошибка, то результат автоматически будет отрицательным)
    44                                  
    45                                      ; Считываем второе число
    46 00000091 B800000000                  mov rax, 0
    47 00000096 BF00000000                  mov rdi, 0
    48 0000009B 48BE-                       mov rsi, secondNum
    48 0000009D [1000000000000000] 
    49 000000A5 BA00010000                  mov rdx, 256
    50 000000AA 0F05                        syscall
    51                                      
    52 000000AC 4883F800                    cmp rax, 0
    53 000000B0 0F8EC5010000                JLE errorSection; Ошибка - и 0, и отрицательное число
    54                                  
    55 000000B6 48890425[18000000]          mov [secondNumLen], rax
    56 000000BE 48BF-                       mov rdi, secondNum
    56 000000C0 [1000000000000000] 
    57 000000C8 488B1C25[18000000]          mov rbx, [secondNumLen]
    58                                  
    59 000000D0 E89E000000                  call stringToNumberSection
    60                                      
    61 000000D5 4989F3                      mov r11, rsi ; В r11 храним второе число
    62                                      
    63 000000D8 4D01DA                      add r10, r11
    64 000000DB 4D89D4                      mov r12, r10 ; в r12 храним сумму чисел
    65                                      
    66 000000DE 488B0425[08000000]          mov rax, [firstNumLen]
    67 000000E6 48390425[18000000]          cmp [secondNumLen], rax
    68 000000EE 760A                        jbe .secondIsBigger
    69 000000F0 488B3C25[08000000]          mov rdi, [firstNumLen]
    70 000000F8 EB08                        jmp .pre_convert
    71                                  
    72                                      .secondIsBigger:
    73 000000FA 488B3C25[18000000]              mov rdi, [secondNumLen]
    74                                  
    75                                      .pre_convert:
    76                                          ; длина суммы может быть больше максимального числа только на 1 символ
    77 00000102 4883C702                        add rdi, 2
    78 00000106 48893C25[28000000]              mov [sumLen], rdi
    79 0000010E 48BB-                           mov rbx, sum
    79 00000110 [2000000000000000] 
    80                                      
    81 00000118 E8D8000000                  call numberToStringSection
    82                                      ; Результат лежит в sum
    83                                      
    84                                      ; Сообщение о сумме
    85 0000011D B801000000                  mov rax, 0x1
    86 00000122 BF01000000                  mov rdi, 0x1
    87 00000127 48BE-                       mov rsi, resultMes
    87 00000129 [2900000000000000] 
    88 00000131 BA08000000                  mov rdx, resultMesLen
    89 00000136 0F05                        syscall
    90                                      
    91 00000138 4883F808                    cmp rax, resultMesLen ; rax не меняется, код ошибки не теряем, если она есть
    92 0000013C 0F8C39010000                JL errorSection ; % Выведено меньше символов, чем ожидалось (если есть ошибка, то результат автоматически будет отрицательным)
    93                                  
    94                                      ; Сумма
    95 00000142 B801000000                  mov rax, 0x1
    96 00000147 BF01000000                  mov rdi, 0x1
    97 0000014C 48BE-                       mov rsi, sum
    97 0000014E [2000000000000000] 
    98 00000156 488B1425[28000000]          mov rdx, [sumLen]
    99 0000015E 0F05                        syscall
   100                                      
   101 00000160 483B0425[28000000]          cmp rax, [sumLen] ; rax не меняется, код ошибки не теряем, если она есть
   102 00000168 0F8C0D010000                JL errorSection ; % Выведено меньше символов, чем ожидалось (если есть ошибка, то результат автоматически будет отрицательным)
   103                                  
   104 0000016E E92F010000                  jmp exitSection
   105                                      
   106                                  
   107                                  
   108                                  stringToNumberSection:
   109                                      ; rdi хранит указатель на число
   110                                      ; rbx хранит длину введённого числа
   111                                      ; r8 - 10, основание системы счисления
   112                                      ; r9 - множитель (степень 10)
   113                                      ; r12 - знак;
   114                                      ; rsi - результат расчёта
   115                                      
   116 00000173 41B80A000000                mov r8, 10
   117 00000179 41B901000000                mov r9, 1 ; начинаем с 1, потом 10 и т.д.
   118 0000017F B900000000                  mov rcx, 0 ; счётчик цикла
   119 00000184 BE00000000                  mov rsi, 0 ; обнуляем результат
   120 00000189 41BC00000000                mov r12, 0 ; обнуляем знак
   121                                      
   122                                      ; Проверяем и убираем символ переноса строки
   123 0000018F 807C1FFF0A                  cmp byte [rdi + rbx - 1], 10
   124 00000194 7508                        jne .check_sign
   125                                      ; Убираем \n, он же 10
   126 00000196 C6441FFF00                  mov byte [rdi + rbx - 1], 0
   127 0000019B 48FFCB                      dec rbx
   128                                      
   129                                  .check_sign:
   130                                      ; Проверяем первый символ на знак минус
   131 0000019E 8A07                        mov al, [rdi]
   132 000001A0 3C2D                        cmp al, '-'
   133 000001A2 750C                        jne .start_convert
   134                                      ; Устанавливаем флаг отрицательности и пропускаем знак
   135 000001A4 41BC01000000                mov r12, 1
   136 000001AA 48FFC7                      inc rdi ; пропускаем знак минус
   137 000001AD 48FFCB                      dec rbx ; уменьшаем длину
   138                                  
   139                                  .start_convert:
   140                                      ; Начинаем с конца строки
   141 000001B0 4889D9                      mov rcx, rbx
   142 000001B3 48FFC9                      dec rcx
   143                                      
   144                                  .loopStrNum:
   145 000001B6 4883F900                    cmp rcx, 0
   146 000001BA 7C2F                        jl .check_negative  ; если счётчик 0, значит мы дошли до первого символа
   147                                      
   148 000001BC 8A040F                      mov al, [rdi + rcx] ; текущий символ(считываем только 1 , если бы считывали в rax, то 8 байт бы считывали)
   149                                      
   150                                      ; Проверяем, что ввели цифру (символ в ASCII лежит выше символа 0 и ниже символа 9)
   151 000001BF 3C30                        cmp al, '0'
   152 000001C1 0F8C8D000000                jl nanSection
   153 000001C7 3C39                        cmp al, '9'
   154 000001C9 0F8F85000000                jg nanSection
   155                                      
   156                                      ; Преобразуем символ в цифру путем вычетания ASCII кода из 0
   157 000001CF 2C30                        sub al, '0'
   158                                      
   159 000001D1 480FB6C0                    movzx rax, al ; расшариваем 1 байт на 8
   160 000001D5 490FAFC1                    imul rax, r9 ; умножаем на текущий разряд (1, 10, 100)
   161 000001D9 4801C6                      add rsi, rax ; добавялем к результату
   162                                      
   163                                      ; Увеличиваем текущий разряд в "разрядность системы" раз
   164 000001DC 4C89C8                      mov rax, r9
   165 000001DF 490FAFC0                    imul rax, r8
   166 000001E3 4989C1                      mov r9, rax
   167                                      
   168 000001E6 48FFC9                      dec rcx ; сдвигаем иднекс в сторону начала строки
   169 000001E9 EBCB                        jmp .loopStrNum
   170                                  
   171                                   .check_negative:
   172                                      ; Если был знак минус, инвертируем результат и заканчиваем
   173 000001EB 4983FC01                    cmp r12, 1
   174 000001EF 7503                        jne .doneStrNum
   175 000001F1 48F7DE                      neg rsi
   176                                   
   177                                      
   178                                  .doneStrNum:
   179 000001F4 C3                          ret
   180                                      
   181                                  numberToStringSection:
   182                                      ; r12 содержит исходное число(делимое)
   183                                      ; rbx хранит указатель на число
   184                                      ; rdi хранит длину результата числа
   185                                      ; rsi будет хранить целую часть от деления
   186                                      ; r9 - 10, основание системы счисления
   187                                      ; r13 - флаг отрицательности
   188                                      
   189 000001F5 41B90A000000                mov r9, 10
   190 000001FB BE00000000                  mov rsi, 0 ; обнуляем результат
   191 00000200 41BD00000000                mov r13, 0 ; флаг отрицательности
   192                                      
   193                                      ; Проверяем, отрицательное ли число
   194 00000206 4983FC00                    cmp r12, 0
   195 0000020A 7909                        jns .positive
   196                                      ; Если отрицательное, устанавливаем флаг и берем модуль
   197 0000020C 41BD01000000                mov r13, 1
   198 00000212 49F7DC                      neg r12
   199                                  
   200                                  .positive:
   201 00000215 4889F9                      mov rcx, rdi
   202 00000218 48FFC9                      dec rcx ; Указываем на последний символ (резервируем под \n)
   203 0000021B 48FFC9                      dec rcx ; Указываем на последную цифру
   204                                      
   205                                  .loopNumStr:
   206 0000021E BA00000000                  mov rdx, 0 ; Обнуляем остаток от деления
   207 00000223 4C89E0                      mov rax, r12 ; Записываем в rax делимое
   208 00000226 49F7F1                      div r9 ; в rax - целая часть, в rdx - остаток от деления
   209 00000229 4989C4                      mov r12, rax
   210                                  
   211 0000022C 4889C6                      mov rsi, rax ; запоминаем целую часть
   212 0000022F 4883C230                    add rdx, '0'  ; сдвигаем на символ 0, чтобы преобразовать в число
   213 00000233 88140B                      mov byte [rbx + rcx], dl; записываем цифру в итоговый результат
   214                                  
   215 00000236 4883FE00                    cmp rsi, 0 ; если целая часть от деления 0, значит все число перенесено
   216 0000023A 7405                        JE .add_sign
   217 0000023C 48FFC9                      dec rcx
   218 0000023F EBDD                        jmp .loopNumStr
   219                                  
   220                                  .add_sign:
   221                                      ; Если число было отрицательным, добавляем знак минус
   222 00000241 4983FD01                    cmp r13, 1
   223 00000245 7507                        jne .doneNumStr
   224 00000247 48FFC9                      dec rcx
   225 0000024A C6040B2D                    mov byte [rbx + rcx], '-'
   226                                  
   227                                  .doneNumStr:
   228                                      ; Добавляем \n, он же 10
   229 0000024E C6443BFF0A                  mov byte [rbx + rdi - 1], 10
   230 00000253 C3                          ret
   231                                  
   232                                  nanSection:
   233                                      ; Если пользователь ввел не число, нужно вывести ему ошибку
   234                                      ; Вывелись не все символы на экран или есть ошибка
   235                                      ; Код ошибки лежим в rax, здесь возможна какая-то дополнительная логика
   236 00000254 B801000000                  mov rax, 0x1
   237 00000259 BF02000000                  mov rdi, 0x2
   238 0000025E 48BE-                       mov rsi, nanMsg
   238 00000260 [4E00000000000000] 
   239 00000268 BA1A000000                  mov rdx, nanMsgLen
   240 0000026D 0F05                        syscall
   241                                      
   242 0000026F B83C000000                  mov rax, 0x3c
   243 00000274 BF01000000                  mov rdi, 0x1
   244 00000279 0F05                        syscall
   245                                  
   246                                  
   247                                  errorSection:
   248                                      ; Вывелись не все символы на экран или есть ошибка
   249                                      ; Код ошибки лежим в rax, здесь возможна какая-то дополнительная логика
   250 0000027B B801000000                  mov rax, 0x1
   251 00000280 BF02000000                  mov rdi, 0x2
   252 00000285 48BE-                       mov rsi, erMsg
   252 00000287 [3100000000000000] 
   253 0000028F BA1D000000                  mov rdx, erMsgLen
   254 00000294 0F05                        syscall
   255                                      
   256 00000296 B83C000000                  mov rax, 0x3c
   257 0000029B BF01000000                  mov rdi, 0x1
   258 000002A0 0F05                        syscall
   259                                  
   260                                  exitSection:
   261 000002A2 B83C000000                  mov rax, 0x3c
   262 000002A7 BF00000000                  mov rdi, 0x0
   263 000002AC 0F05                        syscall
   264                                  
   265                                  
   266                                  section .data
   267 00000000 456E74657220666972-         firstMes db "Enter first number:", 10
   267 00000009 7374206E756D626572-
   267 00000012 3A0A               
   268                                      firstMesLen equ $ - firstMes
   269 00000014 456E74657220736563-         secondMes db "Enter second number:", 10
   269 0000001D 6F6E64206E756D6265-
   269 00000026 723A0A             
   270                                      secondMesLen equ $ - secondMes
   271 00000029 53756D206973200A            resultMes db "Sum is ", 10
   272                                      resultMesLen equ $ - resultMes
   273 00000031 4572726F7220686170-         erMsg db "Error happed during writing!", 10
   273 0000003A 70656420647572696E-
   273 00000043 672077726974696E67-
   273 0000004C 210A               
   274                                      erMsgLen equ $ - erMsg
   275 0000004E 596F7520656E746572-         nanMsg db "You entered not a number!", 10
   275 00000057 6564206E6F74206120-
   275 00000060 6E756D626572210A   
   276                                      nanMsgLen equ $ - nanMsg
   277                                  
   278                                  section .bss
   279 00000000 ????????????????            firstNum resb 8  ; Буфер для первого числа
   280 00000008 ????????????????            firstNumLen resq 1 ; Длина первого числа
   281 00000010 ????????????????            secondNum resb 8 ; Буфер для второго числа
   282 00000018 ????????????????            secondNumLen resq 1 ; Длина второго числа
   283 00000020 ????????????????            sum resb 8  ; Буфер для суммы числа
   284 00000028 ????????????????            sumLen resq 1 ; Длина второго числа
   285                                  
